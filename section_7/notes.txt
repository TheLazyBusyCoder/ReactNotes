//////////////////////////
/// THINKING IN STATES 

// local state 

// global state 
  we can define global state with , Contex API , Redux

// Lifting states up = moving local state to the common parent component. 

// we can pass even state function in the props 

// Deleting an element from an array 
setItems((items) => {
      return items.filter((item) => {
        return item.id !== id;
      });
    });


// Updating an item 
function handelUpdate(id) { // if id is equal => change the item.packed
    setItems((items) => {
      return items.map((item) => {
        return item.id === id ? { ...item, packed: !item.packed } : item;
      });
    });
  }


//////////////////////////
/// DERIVED STATE

// a state where other variables are dependent on 

const [cart , setCart] = useState([
  {id: 1 , name: 'a' , price: 5},
  {id: 2 , name: 'a' , price: 5},
  {id: 3 , name: 'a' , price: 5},
]);

const num = cart.length; 
const totalPrice = cart.reduce((acc , cur) => acc + cur , 0);

// EXAMPLE of derived state 
  function Stats({ items }) {
    if (!items.length) return <em className="status">Start packing somthing</em>;

    // these are variables that depends on the items state. 
    const n = items.length;
    const p = items.filter((ele) => ele.packed === true).length;
    const per = Math.round((p / n) * 100);
    return (
      <footer className="status">
        <em>
          {per === 100
            ? "You have packed everything"
            : `You have ${n} items on your list and you already packed ${p} (${per}%)`}
        </em>
      </footer>
    );
  }

// to sort strings 
  const a = ['leo', 'peop'];

  const output = a.slice().sort((a , b) => a.localCompare(b));

  <select value={state} onChange={(e) => setState(e.target.value)}>
    <option value='one'>a</option>
    <option value='one'>b</option>
    <option value='one'>c</option>
  </select>


// shifting Components to different files 

  shift the function to new file , with Name.js and export default and import necessry file , and then import Name from "./Name";


//////////////////////////
/// CHILDREN PROP

# Why we use this: 
  -> we use this so that we can pass some data which may differ, 
  -> component is same , but the data is not same , like the Next and Previous text data 

# old way
// <Button /> 

# if we want to use children prop
// <Button one={a} two={b} >Some HTML</Button> 
// <Button one={a} two={b} >Previous</Button> 

// inside the Button Component to recieve the between data. 

// function Button({one , two , children}) {
  return <button>{children}</button;  // children data is different 
}


