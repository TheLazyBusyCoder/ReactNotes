//////////////////////////
/// SETTING COMPONENT SIZE

	when component needs a lot of props , its to large 

	abstraction = to hide details 

	// when to seperate big component to small component 
	1. logical seperation of content/layout
	2. Reusability 
	3. Responsibilites / complexity 

	creating new components creats more abstraction (hiding of details)
	never declare new component inside of an component.

  // 3 types of natural component's 

  1. Stateless (presentational component)
  2. Statefull components 
  3. structural components 

//////////////////////////
/// PROP DRILLING 

  // when we need to pass a state to a compnent that is deeply nested 

//////////////////////////
/// COMPONENT COMPOSITION 

  // passing components using the children props 
  // fixes problem of prop drilling 

  // EXAMPLE: 

  // 3 components 1. one , 2. two , 3. three
  // one has two; two needs three; 
  // passing three to two on one , as children props

  <NavBar>
    <Logo />
    <SearchBar />
    <NumResults movies={movies} />
  </NavBar>

  // when every there is a extra passing of the state through components 1->2->3->4 ; 2 and 3 dont need it , so we do component composition , see example inside usepopcorn 

//////////////////////////
/// REUSABLE COMPONENT USING CC

  // Basically its just we are trying to use children and getting rid of reusable code
        <Main>
          <Box>
            <WatchedMovies movies={movies} />
          </Box>
          <Box>
            <WatchedSummary watched={watched} />
            <WatchedMovieList watched={watched} />
          </Box>
        </Main>

  2. way 
        <Box element={<WatchedMovies movies={movies} />} />
          <Box
            element={
              <>
                <WatchedSummary watched={watched} />
                <WatchedMovieList watched={watched} />
              </>
            }
          />


//////////////////////////
/// HANDLING HOVER EFFECT

  onMouseEnter={tempIn}
  onMouseLeave={tempOut}

  //EXAMPLE: 
    export default function StarRating({ maxRating = 5 }) {
      const [rating, setRating] = useState(0);
      const [tempRating, setTempReating] = useState(0);

      function handleRating(val) {
        setRating(val);
      }

      function handelTempRatingIn(val) {
        setTempReating(val);
      }
      function handelTempRatingOut() {
        setTempReating(0);
      }

      return (
        <div style={containerStyle}>
          <div style={containerStarStyle}>
            {Array.from({ length: maxRating }, (_, i) => {
              return (
                <Star
                  key={i}
                  onRate={() => handleRating(i + 1)}
                  full={tempRating ? tempRating >= i + 1 : rating >= i + 1}
                  tempIn={() => handelTempRatingIn(i + 1)}
                  tempOut={() => handelTempRatingOut()}
                />
              );
            })}
          </div>
          <p style={textStyle}>{tempRating || rating || ""}</p>
        </div>
      );
    }

    const starStyle = {
      display: "block",
      cursor: "pointer",
      height: "48px",
      width: "48px",
    };

    function Star({ onRate, full, tempIn, tempOut }) {
      return (
        <span
          role="button"
          onClick={onRate}
          style={starStyle}
          onMouseEnter={tempIn}
          onMouseLeave={tempOut}
        >


//////////////////////////
/// PROPS AS AN COMPONENT API

  // 1. Creater 2. Consumer 

  // Make component such that it balances the number of props , not too much , not too less , medium , 

  // we can send styles with props , its a lot of stuff.
  // also we can send class names. 

//////////////////////////
/// PROPTYPES

// to check the type of the prop that user is passing , 

import PropTypes from "prop-types";

// isRequired if the value should be present
// but rather than this , use default values. 

StarRating.propTypes = {
  maxRating: PropTypes.number.isRequired,
}

PropTypes.string,
PropTypes.array,
PropTypes.func,





