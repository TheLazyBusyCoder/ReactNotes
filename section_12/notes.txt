//////////////////////////
/// EFFECTS AND DATA FETCHING


//////////////////////////
/// Component life cycle 

  // life cycle of a component (blueprint) instance (house)

  // Rerender also happens : 1. state changes, 2. props changes, 3. Parent re-renders, 4. Context changes.

//////////////////////////
/// USEEFFECT

    useEffect(function () {
      fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=moon`)
        .then((res) => res.json())
        .then((data) => setMovies(data.Search));
    }, []);

  // empty array means , as soon as the App() loads it will get executed 1 time. 
  // this will run after the component is painted to the screen 

  // side effects should not be in render logic 

  1. Event handlers. 
  2. useEffect hook -> when we want to do side effect (fetch) when the component is painted or loaded

  // Execution of the useEffect() depends on the dependency array.
  // effect returns a cleanup function

    useEffect(function () {
      fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=moon`)
        .then((res) => res.json())
        .then((data) => setMovies(data.Search));

        return () => {};  // runs before the component re-renders or unmounts 
    }, []);

  // Event handlers are the prefered way of doing sideeffects 

  // Using an async function inside useEffect() 
    useEffect(function () {
      async function getMovie() {
        const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=moon`);
        const data = await res.json();
        setMovies(data.Search);
      }
      getMovie();
    }, []);

//////////////////////////
/// LOADING STATE

  // When data is arriving we use this thing

  const [isLoading, setIsLoading] = useState(false);


  useEffect(function () {
    async function getMovie() {
      setIsLoading(true); // here 
      const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=moon`);
      const data = await res.json();
      setMovies(data.Search);
      setIsLoading(false);  // here 
    }
    getMovie();
  }, []);

        <Box>{isLoading ? <Loader /> : <WatchedMovies movies={movies} />}</Box>

  function Loader() {
    return <p className="loader">Loading...</p>;
  }

//////////////////////////
/// HANDELING ERRORS

  // net is diss connected

  useEffect(function () {
    async function getMovie() {
      try {
        setIsLoading(true);
        const res = await fetch(
          `http://www.omdbapi.com/?apikey=${KEY}&s=adfadfa`
        );
        if (!res.ok) throw new Error("Somthing went wrong :(");
        const data = await res.json();
        if (data.Response === "False") throw new Error("Movie not found");
        setMovies(data.Search);
      } catch (err) {
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    }
    getMovie();
  }, []);


        <Box>
          {isLoading && <Loader />}
          {!isLoading && !error && <WatchedMovies movies={movies} />}
          {error && <ErrorBox message={error} />}
        </Box>


//////////////////////////
/// USE EFFECT DEPENDANCY ARRAY

  // effects runs after the browser is painted 

  By default effects runs after every render, We can prevent that by passing an dependency array.

  // we put props and state variables inside the array 

  // whenever a dependency or state or prop is changed , effect is executed again. 

  useEffect(fn , [x ,y , z]); // this will run when the state changes.
  useEffect(fn , []); // this will run only once
  useEffect(fn);  // effect will run on every render (bad idea).

  // LayoutEffect -> runs in between commit and browser paint 

  // first render logic runs 

  // As the query varialbe changes , we do a new fetch request. 

  // Changling page title

  inside the useEffect() => document.title = "some title";

//////////////////////////
/// CLEANING FUNCTION USEEFFECT

  // a function that runs every thing when the component re renders

  // we return from an effect 

  // 1. before the effect is executed again 
  // 2. after an componenet has unmounted. 

  // Things we should do in cleanup function 
  // http request -> cancle request 
  api subscription -> cancle subscription 
  start timer -> stop timer 
  add event listener -> remove listener 

  // becaues of closure this function has access to the variables. 

  return function() {
    document.title = "blabla"; 
  }

//////////////////////////
/// CLEANING UP FETCH REQUEST

  // we are doing this coz on each key stroke we are sending an request

      // outside async function
      const controller = new AbortController();


      const res = await fetch(
            `http://www.omdbapi.com/?apikey=${KEY}&s=${query}`,
            {
              signal: controller.signal,
            }

            inside catch(err) 
          if (err.name !== "AbortError") setError(err.message);


        return function () {
        controller.abort();
      };


//////////////////////////
/// LISTNING TO KEY PRESS

  // useEffect() is also called as escap hatch , coz we manipulate dom there. 

  // in the app component 
  useEffect(function() {
    document.addEventListener('keydown' , function(e) {
      if(e.code === 'Escape') {
        handleCloseMovie();
      }
    });
  } , []);

  // now shift this in the WatchMovieDetails 
  // and we have to pass the function and we need to include that function in the dependency array.

  useEffect(function() {
    document.addEventListener('keydown' , function(e) {
      if(e.code === 'Escape') {
        onCloseMovie();
      }
    });
  } , [onCloseMovie]);

  // now we even have to remove the event listener when the movie details tab is not showing , so we use cleaningup funciton.

  useEffect(function() {

    function thethe(e) {
      if(e.code === 'Escape') {
        onCloseMovie();
      }
    }
    document.addEventListener('keydown' , thethe);

    return function() {
      document.removeEventListener('keydown' , thethe);
    }
  } , [onCloseMovie]);






